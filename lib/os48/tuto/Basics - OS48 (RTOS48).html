<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Yves DEMIRDJIAN">
        <link rel="canonical" href="http://wwww.rtos48.com/tuto/basics/">
        <link rel="shortcut icon" href="http://rtos48.com/img/favicon.ico">

	<title>Basics - OS48  (RTOS48) - A RTOS kernel provided as an Arduino lib to run multiple tasks at the same time</title>

        <link href="Basics%20-%20OS48%20%28RTOS48%29_fichiers/bootstrap-custom.css" rel="stylesheet">
        <link href="Basics%20-%20OS48%20%28RTOS48%29_fichiers/font-awesome-4.css" rel="stylesheet">
        <link rel="stylesheet" href="Basics%20-%20OS48%20%28RTOS48%29_fichiers/highlight.css">
        <link href="Basics%20-%20OS48%20%28RTOS48%29_fichiers/base.css" rel="stylesheet">
        <link href="Basics%20-%20OS48%20%28RTOS48%29_fichiers/style.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body style="background-image: url(&quot;../../grid.png&quot;);">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="http://rtos48.com/">OS48  (RTOS48) - A RTOS kernel provided as an Arduino lib to run multiple tasks at the same time</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li>
                    <a href="http://rtos48.com/">Home</a>
                </li>
            
            
            
                <li>
                    <a href="http://rtos48.com/download/">Download</a>
                </li>
            
            
            
                <li>
                    <a href="http://rtos48.com/doc/">Library doc</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tutorial <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="http://rtos48.com/tuto/getting_started/">Getting started</a>
                        </li>
                    
                        <li class="active">
                            <a href="http://rtos48.com/tuto/basics/">Basics</a>
                        </li>
                    
                        <li>
                            <a href="http://rtos48.com/tuto/advanced_usage/">Advanced usage</a>
                        </li>
                    
                        <li>
                            <a href="http://rtos48.com/tuto/special_usage/">Special usage</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="http://rtos48.com/about/contact/">Contact</a>
                        </li>
                    
                        <li>
                            <a href="http://rtos48.com/about/licence/">Licence</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a rel="next" href="http://rtos48.com/tuto/getting_started/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li>
                    <a rel="prev" href="http://rtos48.com/tuto/advanced_usage/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#basics">Basics</a></li>
        
            <li><a href="#introduction-of-tasks">Introduction of tasks</a></li>
        
    
        <li class="main "><a href="#tasks">Tasks</a></li>
        
            <li><a href="#get-errors-code">Get errors code</a></li>
        
            <li><a href="#detect-unauthorized-memory-overwrites">Detect unauthorized memory overwrites</a></li>
        
            <li><a href="#print-traces">Print traces</a></li>
        
            <li><a href="#stop-the-scheduler">Stop the scheduler</a></li>
        
            <li><a href="#delete-a-task">Delete a task</a></li>
        
            <li><a href="#sharing-variables-functions">Sharing variables / functions</a></li>
        
            <li><a href="#priority-of-tasks">Priority of tasks</a></li>
        
            <li><a href="#task-states">Task states</a></li>
        
    
    </ul>
</div></div>
            <div style="font-family: calibri,times new roman; font-size: 1.1em;" class="col-md-9" role="main">

<h1 id="basics">Basics</h1>
<h2 id="introduction-of-tasks">Introduction of tasks</h2>
<p>What is a task? A task is an entity managing the life cycle of
the execution of a function. A task evolves in a multitasking context 
which means that many tasks are in competition
to get the CPU time resource at the same time (because the CPU can have 
only one thread of operations). Only one task will be choosen during a 
given time slot.
This is the role of the <em>Scheduler</em>, ordering the tasks and giving them a determined amount of time before letting another task get the CPU resources and so on.</p>
<p><img oldwith="987" alt="Screenshot" src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/task_intro.png" width="855"></p>
<h1 id="tasks">Tasks</h1>
<p>As you can see in the <a href="http://rtos48.com/tuto/getting_started/">Getting started</a> page, you can create a task by calling the function 
<code>Scheduler::createTask()</code> on the scheduler instance. For the moment, there are 3 sort of tasks:</p>
<ul>
<li>the <em>normal</em> task which executes a function</li>
<li>the timer task which allows to a function to be executed at a specific interval of time</li>
<li>the work queue task which enqueues functions which have no deadlines</li>
</ul>
<p>The last two sort of tasks are described in <a href="http://rtos48.com/tuto/special_usage/">Special usage</a> page of this tutorial.</p>
<p>To create a task you need to declare it as a global variable: <code>Task* task1 = NULL;</code>.
Then, in the setup function assign this pointer by calling <code>Scheduler::createTask()</code>: </p>
<p><code>task1 = scheduler-&gt;createTask(&amp;func1, 60, PrNormal);</code>.</p>
<p>The first argument is the address of the function you want to 
associate with the task. The second is the amount of memory you want to 
reserve
for your task (for the stack because each task as its own stack). The 
third parameter defines the priority relative to the
other tasks you will create (PrLow, PrNormal, PrHigh).</p>
<pre><code class="hljs cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> os48;

Scheduler* scheduler = Scheduler::get();

Task* task1 = NULL; 

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{  
  task1 = scheduler-&gt;createTask(&amp;func1, <span class="hljs-number">60</span>, PrNormal);

  <span class="hljs-comment">//[...]</span>

  scheduler-&gt;start();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">//[...]</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span>
</span>{
}
</code></pre>

<blockquote style="border-left: 4px solid rgb(254, 154, 46); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">A task using the <em>Serial</em> object should reserve a lot of memory (&gt; 50 bytes).</p>
</blockquote>
<!-- -->

<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">Inside the function associated to your task, you can use <code>task()-&gt;</code> which returns the instance of the
current task executing this function.</p>
</blockquote>
<p>More tasks you create, the more the system will be slow, because 
there will be more tasks in competition. Also the memory can quickly 
overflow.
To avoid these situations, you have to think how optimize your 
application by asking yourself: </p>
<ul>
<li>how much memory this task really needs?</li>
<li>how many tasks I need, can I reduce their number? (By using a work queue task for example)</li>
<li>Have I forget to delete my task when this one has terminated its execution in order to save memory?</li>
<li>should I have get a more powerful Arduino board?</li>
<li>What priority assign to my task and which kind of scheduling algorithm apply to them?</li>
<li>and so on</li>
</ul>
<p>These questions can be difficult to understand at the beginning but don't worry, that will be soon spontaneous.</p>
<h2 id="get-errors-code">Get errors code</h2>
<p>Functions of the lib may generate an error code for some reasons. For example, if you give to a function some wrong arguments.</p>
<p>In the same way that Linux and the variable errno, OS48 provides its own variables.</p>
<p>To retrieve the last error code you can use <code>Scheduler::getLastError()</code> or <code>Task::getLastError()</code>. 
The functions returning an error are described in the library <a href="http://rtos48.com/doc/">documentation</a>.</p>
<p>You can see below an example of a recommended usage. </p>
<pre><code class="hljs livescript"><span class="hljs-literal">void</span> func1()
{
  <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-params">(!task()-&gt;resume())</span>
  {
    <span class="hljs-title">if</span> <span class="hljs-params">(task()-&gt;getLastError() == TskErrIncorrectState)</span>
    {
      <span class="hljs-title">OS48_ATOMIC_BLOCK</span>
      {
        <span class="hljs-title">Serial</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">"My task is not suspended or sleeping !"</span>)</span>;
      }
    }
  }
}
</span></code></pre>

<p>The error codes returned are described in the library <a href="http://rtos48.com/doc/">documentation</a>.
In the example above, the function returns <code>TskErrIncorrectState</code> meaning that the function expects a non-alive task.</p>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">The error code is stored until you call a kernel function which may return another error.</p>
</blockquote>
<h2 id="detect-unauthorized-memory-overwrites">Detect unauthorized memory overwrites</h2>
<p>You should know that the 8-bits AVR MCUs don't provides a MMU unit within. So the memory areas reserved for each task
are not protected against a write beyond their limits. </p>
<p>The size you pass in argument to create a task is very important and 
you have to think well about how much memory you want to reserve to your
 task. If you give an overestimated size, you risk to waste memory 
space. On the contrary, if you underestimate the size, you have a bigger
 risk to cause a memory overflow. </p>
<p>The library provides overflow detections in order to inform you that your program take a bigger memory size than you expected.</p>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">For experimented users, in the <em>Advanced_parameters.h</em> file, you can disable the detection in order to save CPU resources during the context switch.</p>
</blockquote>
<p>It's recommended to use the function <code>Scheduler::setStackOverflowFnc(void_fnc_t fnc)</code>. The kernel
executes the code in this function if it detects a stack overflow (interrupts are disabled in the function). 
You will be able to know why your program causes malfunctions. If no function is specified, the kernel will execute
an infinite loop.</p>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">After the completion of this custom function, the kernel enters, by default, in an infinite loop.</p>
</blockquote>
<p>See the example below. The example sets deliberately the size to 0 byte to show you a stack overflow.</p>
<pre><code class="hljs gradle">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

Scheduler* scheduler = Scheduler::get();

<span class="hljs-keyword">Task</span>* task1 = <span class="hljs-keyword">NULL</span>;

<span class="hljs-keyword">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;doOverflow, <span class="hljs-number">0</span>);

  scheduler-&gt;setStackOverflowFnc(&amp;fncSO); <span class="hljs-comment">// &lt;-- Define your custom function here</span>

  scheduler-&gt;start();
}

<span class="hljs-keyword">void</span> doOverflow()
{
  <span class="hljs-comment">/**
   * This function takes 3 bytes.
   * 1 for the variable 'i'
   * 2 for the volatile keyword to store the address of i
   * 
   * Note to advanced users:
   * volatile ensures i is read and write at each access in order to avoid
   * GCC optimizations (without volatile the compiler removes the loop)
   */</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">byte</span> i = <span class="hljs-number">0</span>; ; ++i) {}<span class="hljs-comment">//busy wait</span>
}

<span class="hljs-keyword">void</span> fncSO()
{
  Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Stack overflow!"</span>);
  Serial.<span class="hljs-keyword">print</span>(<span class="hljs-string">"ID of the task affected: "</span>);
  Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getId());
  Serial.<span class="hljs-keyword">print</span>(<span class="hljs-string">"Free stack size: "</span>);
  Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getUserFreeStackSize()); 
  Serial.flush();
}


<span class="hljs-keyword">void</span> loop() {}
</code></pre>

<p>This is a representation of an overlow:</p>
<p><img alt="Screenshot" src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/simple_overflow.png"></p>
<h2 id="print-traces">Print traces</h2>
<p>In order to have some helps in your development, the kernel provides some functions to get statistics:</p>
<ul>
<li><code>Scheduler::print(HardwareSerial&amp;)</code> to get few informations about the scheduler (may be improved in a future version)</li>
<li><code>Task::print(HardwareSerial&amp;, bool printHeaders = false)</code> to get few informations about a task such as usage ratio, priority, ...</li>
<li><code>Task::printMem(HardwareSerial&amp;, bool printHeaders = false)</code> to get few informations about the stack of a task</li>
</ul>
<blockquote style="border-left: 4px solid rgb(254, 154, 46); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">Call <code>Task::clearStackFootprints()</code> just after the creation of the task for <code>Task::printMem()</code>.</p>
</blockquote>
<p>Example of <code>Task::print()</code> and <code>Scheduler::print()</code>:</p>
<pre><code class="hljs gradle">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

Scheduler* scheduler = Scheduler::get();

<span class="hljs-keyword">Task</span>* task1 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task2 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* taskP = <span class="hljs-keyword">NULL</span>;

<span class="hljs-keyword">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Creating tasks..."</span>);

  task1 = scheduler-&gt;createTask(&amp;task1Func, <span class="hljs-number">20</span>, PrHigh); <span class="hljs-comment">//id 1</span>
  task2 = scheduler-&gt;createTask(&amp;task2Func, <span class="hljs-number">20</span>); <span class="hljs-comment">//id 2</span>
  taskP = scheduler-&gt;createTask(&amp;taskPFunc, <span class="hljs-number">150</span>); <span class="hljs-comment">//id 3</span>

  Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Starting..."</span>);

  scheduler-&gt;start();
}

<span class="hljs-keyword">void</span> taskPFunc()
{
  <span class="hljs-keyword">for</span> (;;)
  {
    <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">2000</span>);

    OS48_ATOMIC_BLOCK <span class="hljs-comment">// &lt;-- disable all interrupts to prevent update of internal variables (because the prints consume also CPU time)</span>
    {
      Serial.<span class="hljs-keyword">println</span>(F(<span class="hljs-string">"----------------"</span>));
      task1-&gt;<span class="hljs-keyword">print</span>(Serial, <span class="hljs-keyword">true</span>);
      task2-&gt;<span class="hljs-keyword">print</span>(Serial);
      taskP-&gt;<span class="hljs-keyword">print</span>(Serial);
      scheduler-&gt;<span class="hljs-keyword">print</span>(Serial);
      Serial.<span class="hljs-keyword">println</span>(F(<span class="hljs-string">"----------------"</span>));
    }   
  }
}

<span class="hljs-keyword">void</span> task1Func()
{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;; i++) <span class="hljs-comment">//fake work</span>
  {
  }
}

<span class="hljs-keyword">void</span> task2Func()
{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;; i++) <span class="hljs-comment">//fake work</span>
  {
  }
}

<span class="hljs-keyword">void</span> loop() {}
</code></pre>

<p>Note that the task 1 has a high priority and therefore consumes more CPU time than task 2. 
The task 3 consumes almost nothing because this task is asleep most of the time.</p>
<p>You should get something like this (or equivalent):</p>
<p><img oldwith="897" alt="Screenshot" src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/cpu_time.jpg" width="855"></p>
<!-- -->

<p><code>Task::printMem()</code> is usefull in order to have a better idea of the usage of the memory by a task.
While the column <em>Used</em> shows the used memory at the call location , the column <em>Footprint</em> shows the highest amount 
of memory used during the all life cycle of the task. With the column <em>UserTotal</em> and the column <em>Footprint</em>, you can review and adjust the amount of memory reserved for your task. The column <em>%footprint</em> shows the ratio <em>Footprint / UserTotal</em>.</p>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">To get the last footprint as an integer in your code you can call <code>Task::getLastStackFootprint()</code>.</p>
</blockquote>
<p>Example with <code>Task::printMem()</code>:</p>
<pre><code class="hljs gradle">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

Scheduler* scheduler = Scheduler::get();

<span class="hljs-keyword">Task</span>* task1 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task2 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* taskP = <span class="hljs-keyword">NULL</span>;

<span class="hljs-keyword">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Creating tasks..."</span>);

  task1 = scheduler-&gt;createTask(&amp;task1Func, <span class="hljs-number">40</span>); <span class="hljs-comment">//id 1</span>
  task1-&gt;clearStackFootprints(); <span class="hljs-comment">//IMPORTANT to call Task::printMem()</span>
  task2 = scheduler-&gt;createTask(&amp;task2Func, <span class="hljs-number">40</span>); <span class="hljs-comment">//id 2</span>
  task2-&gt;clearStackFootprints(); <span class="hljs-comment">//IMPORTANT to call Task::printMem()</span>
  taskP = scheduler-&gt;createTask(&amp;taskPFunc, <span class="hljs-number">150</span>); <span class="hljs-comment">//id 3</span>
  taskP-&gt;clearStackFootprints(); <span class="hljs-comment">//IMPORTANT to call Task::printMem()</span>

  Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Starting..."</span>);

  scheduler-&gt;start();
}

<span class="hljs-keyword">void</span> taskPFunc()
{
  <span class="hljs-keyword">for</span> (;;)
  {
    <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">2000</span>);

    OS48_ATOMIC_BLOCK <span class="hljs-comment">// &lt;-- disable all interrupts to prevent update of internal variables (because the prints consume also CPU time)</span>
    {
      Serial.<span class="hljs-keyword">println</span>(F(<span class="hljs-string">"----------------"</span>));
      task1-&gt;printMem(Serial, <span class="hljs-keyword">true</span>);
      task2-&gt;printMem(Serial);
      taskP-&gt;printMem(Serial);
    }
  }
}

<span class="hljs-keyword">void</span> task1Func()
{
  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">byte</span> bytes[<span class="hljs-number">5</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;; i++) <span class="hljs-comment">//fake work</span>
  {
    bytes[i % <span class="hljs-number">5</span>] = (<span class="hljs-keyword">byte</span>) i;
  }
}

<span class="hljs-keyword">void</span> task2Func()
{
  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">byte</span> bytes[<span class="hljs-number">15</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;; i++) <span class="hljs-comment">//fake work</span>
  {
    bytes[i % <span class="hljs-number">15</span>] = (<span class="hljs-keyword">byte</span>) i;
  }
}

<span class="hljs-keyword">void</span> loop() {}
</code></pre>

<p>Result:</p>
<p><img oldwith="897" alt="Screenshot" src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/task_mem.jpg" width="855"></p>
<p>Take a look to the <em>Footprint</em> column. The task 2 uses 10 bytes more than the task 1 because of the declaration of the <em>bytes</em> variable which have not the same size.
The task 3 uses a lot of memory because of the usage of the <em>Serial</em> object.</p>
<h2 id="stop-the-scheduler">Stop the scheduler</h2>
<p>Sometimes, it's interresting to stop all tasks. You can use the function <code>Scheduler::stop(void_fnc_t fnc)</code> to perform that. 
The scheduler is stopped  and the function passed as argument will be executed. An infinite loop is executed
after your function execution.</p>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">Interruptions are still enabled.</p>
</blockquote>
<pre><code class="hljs ocaml">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;
using namespace os48;

<span class="hljs-type">Scheduler</span>* scheduler = <span class="hljs-type">Scheduler</span>::get<span class="hljs-literal">()</span>;

<span class="hljs-type">Task</span>* task1 = <span class="hljs-type">NULL</span>;
<span class="hljs-type">Task</span>* task2 = <span class="hljs-type">NULL</span>;

void setup<span class="hljs-literal">()</span> {
  <span class="hljs-type">Serial</span>.<span class="hljs-keyword">begin</span>(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func1, <span class="hljs-number">50</span>);
  task2 = scheduler-&gt;createTask(&amp;func2, <span class="hljs-number">50</span>);

  scheduler-&gt;start<span class="hljs-literal">()</span>;
}

void func1<span class="hljs-literal">()</span>
{
  <span class="hljs-keyword">for</span>(;;)
  {
    <span class="hljs-type">OS48_ATOMIC_BLOCK</span>
    {
      <span class="hljs-type">Serial</span>.println(<span class="hljs-string">"..."</span>);
      task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">500</span>);
    }
  }
}

void func2<span class="hljs-literal">()</span>
{
  task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">2000</span>);
  scheduler-&gt;stop(&amp;stopProcess);
}

void stopProcess<span class="hljs-literal">()</span>
{
  <span class="hljs-type">Serial</span>.println(<span class="hljs-string">"Kernel is stopped"</span>);
}

void loop<span class="hljs-literal">()</span> {}
</code></pre>

<p>You can restart the scheduler inside the function but you need to call <code>Task::reset()</code> on each task before.</p>
<pre><code class="hljs sml"><span class="hljs-type">Serial</span>.println(<span class="hljs-string">"Kernel is stopped"</span>);
<span class="hljs-type">Serial</span>.flush<span class="hljs-literal">()</span>;
task1-&gt;reset<span class="hljs-literal">()</span>;
task2-&gt;reset<span class="hljs-literal">()</span>;
scheduler-&gt;start<span class="hljs-literal">()</span>;
</code></pre>

<h2 id="delete-a-task">Delete a task</h2>
<p>You can delete a task to save memory by using <code>Scheduler::deleteTask()</code></p>
<pre><code class="hljs ocaml">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;
using namespace os48;

<span class="hljs-type">Scheduler</span>* scheduler = <span class="hljs-type">Scheduler</span>::get<span class="hljs-literal">()</span>;

<span class="hljs-type">Task</span>* task1 = <span class="hljs-type">NULL</span>;
<span class="hljs-type">Task</span>* task2 = <span class="hljs-type">NULL</span>;

void setup<span class="hljs-literal">()</span> {
  <span class="hljs-type">Serial</span>.<span class="hljs-keyword">begin</span>(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func1, <span class="hljs-number">60</span>);
  task2 = scheduler-&gt;createTask(&amp;func2, <span class="hljs-number">60</span>);

  scheduler-&gt;start<span class="hljs-literal">()</span>;
}

void func1<span class="hljs-literal">()</span>
{
  <span class="hljs-type">OS48_NO_CS_BLOCK</span>
  {
    <span class="hljs-type">Serial</span>.print(<span class="hljs-string">"Free memory: "</span>);
    <span class="hljs-type">Serial</span>.println(scheduler-&gt;getFreeMemorySize<span class="hljs-literal">()</span>);
    task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">5000</span>);
    scheduler-&gt;deleteTask(task2);
    <span class="hljs-type">Serial</span>.print(<span class="hljs-string">"Free memory: "</span>);
    <span class="hljs-type">Serial</span>.println(scheduler-&gt;getFreeMemorySize<span class="hljs-literal">()</span>);
    <span class="hljs-type">Serial</span>.flush<span class="hljs-literal">()</span>;
  }
}

void func2<span class="hljs-literal">()</span>
{
  <span class="hljs-keyword">for</span> (;;)
  {
    <span class="hljs-type">OS48_NO_CS_BLOCK</span>
    {
      task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">1000</span>);
      <span class="hljs-type">Serial</span>.println(<span class="hljs-string">"task2"</span>);
    }
  }
}

void loop<span class="hljs-literal">()</span> {}
</code></pre>

<h2 id="sharing-variables-functions">Sharing variables / functions</h2>
<h3 id="set-the-same-functions-to-different-tasks">Set the same functions to different tasks</h3>
<p>You can assign the same function to different tasks.</p>
<pre><code class="hljs ocaml">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;
using namespace os48;

<span class="hljs-type">Scheduler</span>* scheduler = <span class="hljs-type">Scheduler</span>::get<span class="hljs-literal">()</span>;

<span class="hljs-type">Task</span>* task1 = <span class="hljs-type">NULL</span>;
<span class="hljs-type">Task</span>* task2 = <span class="hljs-type">NULL</span>;

void setup<span class="hljs-literal">()</span> {
  <span class="hljs-type">Serial</span>.<span class="hljs-keyword">begin</span>(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">60</span>);
  task2 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">60</span>);

  scheduler-&gt;start<span class="hljs-literal">()</span>;
}

void func<span class="hljs-literal">()</span>
{
  <span class="hljs-keyword">for</span> (;;)
  {
    <span class="hljs-type">OS48_ATOMIC_BLOCK</span>
    {
      task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">1000</span>);
      <span class="hljs-type">Serial</span>.println(task<span class="hljs-literal">()</span>-&gt;getId<span class="hljs-literal">()</span>);
    }
  }
}


void loop<span class="hljs-literal">()</span> {}
</code></pre>

<h3 id="share-a-variable-between-different-tasks">Share a variable between different tasks</h3>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">This section of the turorial is very important.</p>
</blockquote>
<p>Assume this code:</p>
<pre><code class="hljs cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> os48;

Scheduler* scheduler = Scheduler::get();

Task* task1 = NULL;
Task* task2 = NULL;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func1, <span class="hljs-number">60</span>);
  task2 = scheduler-&gt;createTask(&amp;func2, <span class="hljs-number">60</span>);

  scheduler-&gt;start();
}

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> shared_i = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">for</span> (;;)
  {
    ++shared_i;
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">for</span> (;;)
  {
    OS48_ATOMIC_BLOCK
    {
      Serial.println((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) shared_i);
    }
  }
}


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{}
</code></pre>

<p>At the execution, you get always <em>0</em>. The reason is very simple. The compiler can optimize the code and it stores
<code>shared_i</code> in a register for the two tasks. Therefore, it doesn't noticed
that the variable can be changed with different threads (because each task has their own register values).</p>
<p>You need to use volatile variable: <code>volatile unsigned int shared_i = 0;</code>. Now, that should work well. </p>
<p>Indeed, <code>volatile</code> notices the compiler to always read and write the variable from the memory. If you omit <code>volatile</code> the variable is always read from the register.</p>
<p>Unfortunately, it's still not perfect. <code>shared_i</code> is stored in two bytes. If you write <code>++shared_i</code>,
the compiler produces the following ASM code :</p>
<pre><code class="hljs sql">LDS R24,0x0142      <span class="hljs-operator"><span class="hljs-keyword">Load</span> direct <span class="hljs-keyword">from</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">space</span> 
LDS R25,<span class="hljs-number">0x0143</span>      <span class="hljs-keyword">Load</span> direct <span class="hljs-keyword">from</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">space</span> 
ADIW R24,<span class="hljs-number">0x01</span>       <span class="hljs-keyword">Add</span> <span class="hljs-keyword">immediate</span> <span class="hljs-keyword">to</span> word 
STS <span class="hljs-number">0x0143</span>,R25      Store direct <span class="hljs-keyword">to</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">space</span> 
STS <span class="hljs-number">0x0142</span>,R24      Store direct <span class="hljs-keyword">to</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">space</span> 
</span></code></pre>

<p>If the kernel interruption occurs between the two <em>STS</em> for example, the task2 will read a corrupted value. You have to 
protect the operation by surrounding it with <code>OS48_ATOMIC_BLOCK</code>:</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">for</span> (;;)
  {
    OS48_ATOMIC_BLOCK
    {
      ++shared_i;
    }
  }
}
</code></pre>

<p>Now, the code is perfect. Note that this macro is useless if the variable would have been stored with 1 byte.</p>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">If you don't want to tag the variable as volatile to keep performances, you can use, when you want it in your code, the macro  <code>OS47_VOLATILE_R(TYPE, VARIABLE)</code> to read and write the variable from stack.</p>
</blockquote>
<p>In the rest of this tutorial, we will see how warn task 2 of a value change using synchronization primitives.</p>
<h2 id="priority-of-tasks">Priority of tasks</h2>
<p>You can assign a priority to a task. By default the scheduling algorithm is Round Robin. You can see how to
change it in in the advanced section of this tutorial. With the Round Robin algorithm, the time slot allocated to a task
depends of its priority. A task with a high priority has more CPU cycles to perform its job.</p>
<p>You can set the priority when you create a task with <code>Task::create()</code> or you can change later the priority on a task 
with <code>Task::setPriority()</code>. You have 5 priority choices: <em>PrHigh</em>, <em>PrAboveNormal</em>, <em>PrNormal</em>, <em>PrBelowNormal</em>, or <em>PrLow</em>. By default, the normal
priority is used when you create a task if the argument is not specified.</p>
<pre><code class="hljs livescript"><span class="hljs-comment">#include &lt;os48.h&gt;</span>
using namespace os48;

Scheduler* scheduler = <span class="hljs-attribute">Scheduler</span>::get();

Task* task1 = NULL;
Task* task2 = NULL;
Task* task3 = NULL;

<span class="hljs-literal">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);

  task1 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">70</span>, PrHigh);
  task2 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">70</span>, PrNormal);
  task3 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">70</span>, PrNormal);

  task3-&gt;setPriority(PrLow);

  scheduler-&gt;start();
}

<span class="hljs-literal">void</span> func()
{
  <span class="hljs-keyword">for</span> (unsigned long i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span> ; ++i)
  {
    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>)
    {
      OS48_NO_CS_BLOCK
      {
        Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">"Task "</span>);
        Serial.<span class="hljs-built_in">print</span><span class="hljs-function"><span class="hljs-params">(task()-&gt;getId())</span>;
        <span class="hljs-title">Serial</span>.<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">": "</span>)</span>;
        <span class="hljs-title">Serial</span>.<span class="hljs-title">println</span><span class="hljs-params">(i)</span>;
      }
    }
  }

  <span class="hljs-title">OS48_NO_CS_BLOCK</span>
  {
    <span class="hljs-title">Serial</span>.<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"Task "</span>)</span>;
    <span class="hljs-title">Serial</span>.<span class="hljs-title">print</span><span class="hljs-params">(task()-&gt;getId())</span>;
    <span class="hljs-title">Serial</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">" done!"</span>)</span>;
  }

  <span class="hljs-title">Serial</span>.<span class="hljs-title">flush</span><span class="hljs-params">()</span>;
}

<span class="hljs-title">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> {}
</span></code></pre>

<p>On the above example, you can see that the task 1 which has the 
highest returns first and its counter is always greater than the other 
tasks.</p>
<h2 id="task-states">Task states</h2>
<p>Tasks have 3 categories of states:</p>
<ul>
<li>alive (aka ready): candidate task to execute/resume.</li>
<li>blocked: tasks are waiting for something</li>
<li>dead: no more code to execute</li>
</ul>
<p>Each category has several states:</p>
<p><img oldwith="989" alt="Screenshot" src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/states.png" width="855"></p>
<p>On the left side you can see how a task can pass to an alive state to a blocked or dead state.
On the right side you can see how a task can be alive.</p>
<blockquote style="border-left: 4px solid rgb(254, 154, 46); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">Whatever
 the previous state of the task, the task state can't be directly 
"running". A state can't be "running" before being "queuing". Only the 
scheduling algorithm
can change the state to "running". That's why a task, previously asleep,
 and which has just been woken up, can't resume immediately its 
execution where it left off before sleep. A task with an higher priority
 can be first chosen.</p>
</blockquote>
<p>You can get at any time the current state of a task with <code>Task::getState()</code>. </p>
<h3 id="suspend-resume-a-task">Suspend / resume a task</h3>
<p>You can suspend temporarly a task with the function <code>Task::suspend()</code> and resume it with
<code>Task::resume()</code>. </p>
<h3 id="sleep-a-task">Sleep a task</h3>
<p>Call <code>Task::sleep()</code> by specifying a duration in milliseconds. You can abort the wait by calling <code>Task::resume()</code>.
The task is again inserted in the list of alive tasks once the period 
has expired. But that does not mean it will be resumed immediately.
That's why, the task will sleep AT LEAST the specified duration before 
the resumption. 
There are many reasons that a task can't resume its process after the 
expected delay:</p>
<ul>
<li>a task with a higher priority is chosen prior (it depends of the scheduling algorithm)</li>
<li>there are too many tasks that have been woken up at the same time</li>
<li>the chosen scheduling algorithm doesn't immediately allow the execution of a woken up task (<em>SchPolicyRandomPriority</em> for example)</li>
</ul>
<blockquote style="border-left: 4px solid rgb(254, 154, 46); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">The sleep function ensures only that the state is StQueuing after the expiration of the delay.</p>
</blockquote>
<p>In the advanced section of this tutorial, we will see that the most responsive algorithm is the '<em>Intelligent</em>'.</p>
<blockquote style="border-left: 4px solid rgb(164, 164, 164); background-color: transparent; margin-bottom: 8px;">
<p style="font-size: 0.9em; font-style: italic; background-color: transparent;">A task having a high priority has more chance to resume its process within the given delay. You can change the task priority
before call the sleep function or think about a more responsive scheduling algorithm.</p>
</blockquote>
<h3 id="abort-a-task">Abort a task</h3>
<p>To abort the job execution of a task you can call <code>Task::abort()</code>. </p>
<h3 id="reset-a-task">Reset a task</h3>
<p>At any time, you can reset the task. The task restarts the execution 
of the function associated. The stack pointer of the task is also reset.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/jquery-1.js"></script>
        <script src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/bootstrap-3.js"></script>
        <script src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/highlight.js"></script>
        <script src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/base.js"></script>
        <script src="Basics%20-%20OS48%20%28RTOS48%29_fichiers/style.js"></script>
    
</body></html>