<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Yves DEMIRDJIAN">
        <link rel="canonical" href="http://wwww.rtos48.com/tuto/advanced_usage/">
        <link rel="shortcut icon" href="http://rtos48.com/img/favicon.ico">

	<title>Advanced usage - OS48  (RTOS48) - A RTOS kernel provided as an Arduino lib to run multiple tasks at the same time</title>

        <link href="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/bootstrap-custom.css" rel="stylesheet">
        <link href="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/font-awesome-4.css" rel="stylesheet">
        <link rel="stylesheet" href="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/highlight.css">
        <link href="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/base.css" rel="stylesheet">
        <link href="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/style.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body style="background-image: url(&quot;../../grid.png&quot;);">

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="http://rtos48.com/">OS48  (RTOS48) - A RTOS kernel provided as an Arduino lib to run multiple tasks at the same time</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li>
                    <a href="http://rtos48.com/">Home</a>
                </li>
            
            
            
                <li>
                    <a href="http://rtos48.com/download/">Download</a>
                </li>
            
            
            
                <li>
                    <a href="http://rtos48.com/doc/">Library doc</a>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tutorial <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="http://rtos48.com/tuto/getting_started/">Getting started</a>
                        </li>
                    
                        <li>
                            <a href="http://rtos48.com/tuto/basics/">Basics</a>
                        </li>
                    
                        <li class="active">
                            <a href="http://rtos48.com/tuto/advanced_usage/">Advanced usage</a>
                        </li>
                    
                        <li>
                            <a href="http://rtos48.com/tuto/special_usage/">Special usage</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li>
                            <a href="http://rtos48.com/about/contact/">Contact</a>
                        </li>
                    
                        <li>
                            <a href="http://rtos48.com/about/licence/">Licence</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a rel="next" href="http://rtos48.com/tuto/basics/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li>
                    <a rel="prev" href="http://rtos48.com/tuto/special_usage/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#advanced-usage">Advanced usage</a></li>
        
            <li><a href="#memory">Memory</a></li>
        
            <li><a href="#how-works-scheduling">How works scheduling</a></li>
        
            <li><a href="#scheduling-algorithms">Scheduling algorithms</a></li>
        
            <li><a href="#comparison-of-the-differents-algorithms">Comparison of the differents algorithms</a></li>
        
            <li><a href="#interruptions-management">Interruptions management</a></li>
        
            <li><a href="#concurrency">Concurrency</a></li>
        
            <li><a href="#messages">Messages</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="advanced-usage">Advanced usage</h1>
<h2 id="memory">Memory</h2>
<p>All the user memory space (all the SRAM except the registers and the 
static variables) is used as a heap memory (aka dynamic memory).
The main stack disappears giving way to dynamically allocated spaces in 
order to store the stack of each task.</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/memory.png"></p>
<p>The kernel uses the standard functions for allocating memory: <code>malloc()</code> / <code>new</code> and <code>free()</code> / <code>delete</code>.</p>
<blockquote>
<p>warning DOn't forget to protect these functions against interrupts when you call them.</p>
</blockquote>
<p>The standard functions are not really fast and memory fragmentation can arise if you allocate / deallocate objects many times. 
To solve theses problems, the kernel provides memory pools. 
Memory pools are usefull to allocate and deallocate many data instances quickly and frequently. 
This is often the case with the exchanged messages between tasks but a little bit less with tasks.</p>
<p>In a memory pool a fixed number of object instances are preallocated 
as blocks and a flag identifies if a block is used or free. 
One memory block can have only one type of object. Each free block is 
linked to the next free block. 
This is a short explanation of the memory pool mechanisms:</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/memory_pool.png"></p>
<p>Default memory pools are already created (in the static memory area) 
for tasks, messages and work objects but no block is reserved
for tasks and work objects. Messages have 6 blocks reserved. If your 
application sends a lot of messages, or, creates and removes many times 
tasks 
, or, uses the <code>TaskWorkQueue</code> very frequently, then you can increase the number of blocks reserved in <em>Advanced_parameters.h</em>.</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/memory2.png"></p>
<p>When you call <code>Scheduler::createTask()</code>, the kernel try to first reserve a memory pool block .
If no block is available, the kernel use the standard <code>malloc()</code> function. When you instanciate a message or 
a work object with the <code>new</code> operator, the same procedure is followed.</p>
<p>You can also use lass <code>MemoryPool</code> class for your own objects.</p>
<blockquote>
<p>See also <a href="https://en.wikipedia.org/wiki/Memory_pool">this link</a> to have more informations.</p>
</blockquote>
<h2 id="how-works-scheduling">How works scheduling</h2>
<blockquote>
<p>warning This is an important part of the documentation. The following explanations can be understanded only by advanced
users.</p>
</blockquote>
<h3 id="kernel-interruption">Kernel interruption</h3>
<p>The timer 0 of your arduino board is configured to execute a micro code at a specific interval for all 
scheduling algorithms expected for the cooperative one. Each time this micro code is 
executed and corresponds to one <em>kernel tick</em>. </p>
<blockquote>
<p>By default, the kernel clock tick occurs every 1024us.</p>
</blockquote>
<p>A kernel tick does not necessarily result in a context switch. 
The scheduling algorithm defines for the chosen task a number of kernel tick before proceeding to a new context switch. 
 More a task has an important number of kernel ticks assigned, more this task has time to run its code. 
Generally, tasks with a high priority get more ticks kernel.</p>
<p>The following example shows how the kernel interruption interrupts 
the process of a task in order to resume the process of another task
(assuming for this example that each task have 1 kernel tick assigned).</p>
<p>The red arrows correspond to the context switch subroutine.</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/parallel_execution.png"></p>
<p>Assume a task which has 3 kernel ticks assigned. At each kernel tick,
 this number will be decremented to 1 until 0. 
At 0, a context switch occurs in order to select a new task to resume 
(and the kernel assigns to the resumed task a new number of kernel ticks
 and so on).</p>
<h3 id="the-context">The context</h3>
<p>To resume the execution of a task at the exact point where it was 
interrupted, the kernel has to save registers, pointer to stack, ... 
All these data, aka <em>the context</em>, are stored on the stack of the current task.</p>
<p>The kernel saves the context of the current task, calls the context switch subroutine and restores the context
of the newly task. </p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/saving_context.png"></p>
<p>When the next task is chosen, the kernel does the exact opposite of the above process.</p>
<h3 id="the-context-switch-subroutine">The context switch subroutine</h3>
<p>A specific number of kernel ticks is attribued for a running task. This is the <em>time slot</em>.
 
When all the time slot is consumed (no kernel ticks remaining) the 
kernel calls the scheduling algorithm in order to choose a new task. The
 new time slot
(the number of kernel ticks) is depending on the task and the scheduling
 algorithm chosen.</p>
<p>Also, at each kernel ticks, the kernel looks for tasks that must be woken up. These tasks are added to the ready queue
and the scheduling algorithm is called.</p>
<p>Before and after the call of the scheduling algorithm the kernel checks also if there is a stack overflow.
Before: in order to check if the stack pointer is beyond the limits of the stack.
After: in order to check if some data have been overwritten on the stack of the new task chosen.</p>
<p>This is the subroutine algorithm:</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/context_switching.png"></p>
<blockquote>
<p>If the idle task is chosen, the time slot is always 1.</p>
</blockquote>
<h3 id="about-tasks">About tasks</h3>
<p>You have two categories of tasks.</p>
<ul>
<li>Alive tasks states are: StRunning or StQueuing. These active tasks are referenced internally in a priority queue 
and are running or are ready to resume execution where it left off.</li>
<li>Non alive tasks are tasks that won't be chosen by the kernel in order to continue their process. These tasks can:<ul>
<li>sleep: sleeping task references are stored in a queue sorted in ascending order by date of resumption.</li>
<li>wait a resource (semaphore for example): task references are stored 
in a queue sorted by a priority FIFO (high priority tasks are dequeued 
first) or a simple FIFO (first in, first out).</li>
<li>have another state (StTerminated, StAborted, StSuspend, ...): task references are NOT stored.</li>
</ul>
</li>
</ul>
<p>The scheduling algorithms choose a task among alive ones. </p>
<p>The idle task is always alive. 
This is a special task chosen when no more tasks are available. This task falls asleep the microcontroller. 
An interruption of the kernel (from the timer 0) interrupts the sleep of the MCU and the context switch subroutine is 
called normally. </p>
<blockquote>
<p>You can change the behaviour of the idle task by assigning a custom function with <code>Scheduler::setIdleUserFnc()</code>.</p>
</blockquote>
<p>The <em>ready queue</em>:</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/tasks.png"></p>
<p>When you create a task (with autostart = true, default behaviour):</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/add_task.png"></p>
<p>When you remove an alive task:</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/remove_task.png"></p>
<h3 id="manually-yield">Manually yield</h3>
<p>When you choose the cooperative scheduling algorithm, you can use the <code>Scheduler::yieldTo(Task* task, bool delayed)</code> function that lets you
yield the running task to another task of your choice. If you set the <em>delayed</em> argument to true, 
the task you pass in the 1st argument will be chosen the next time you call a blocking function of the kernel (e.g <code>Semaphore::acquire()</code>).</p>
<blockquote>
<p>warning Use this function outside the cooperative algorithm is really discouraged.</p>
</blockquote>
<p>You have also the function <code>Scheduler::yield()</code> which, according to the chosen scheduling algortihm, 
yields the current task to another. </p>
<blockquote>
<p>When using the cooperative scheduling policy, this function chooses a task with the same priority or a lower if not.</p>
</blockquote>
<h2 id="scheduling-algorithms">Scheduling algorithms</h2>
<p>You can change the scheduling algorithm at any time with <code>Scheduler::setSchedulingPolicy()</code>.
The kernel uses by default the Round Robin algorithm.</p>
<h3 id="cooperative-algorithm">Cooperative algorithm</h3>
<p>Use <code>Scheduler::setSchedulingPolicy(SchPolicyCoop)</code>. </p>
<p>This is the only mode that allows you to choose deliberately when and which task will be executed after.</p>
<p>The kernel never interrupts itself a task process. This is the best choice to have a full control.</p>
<p>The inconvenient is to have a more complex code, and prone to errors.</p>
<h3 id="preemptive-algorithm">Preemptive algorithm</h3>
<p>Use <code>Scheduler::setSchedulingPolicy(SchPolicyPreemptive)</code>. </p>
<p>This algorithm always chooses the task with the highest priority among the other tasks. 
If multiple tasks have the highest priority, the task chosen will be the next one of the previously executed task.</p>
<p>When a higher priority task than current one is added in the ready 
queue (i.e alive tasks, state StQueuing), a context switching is 
performed.</p>
<p>Lower priority tasks may not be executed even if they have been woken up after a <code>Task::sleep</code>
 call. 
The lower priority tasks will be executed only when all tasks with an 
higher priority are terminated, sleeping, aborted, suspended, and so on.</p>
<p>The advantage is to have a high responsiveness of tasks with an high priority.</p>
<p>The time slot allocated is constant and long (300 kernel ticks ~307 ms) before a context switch. It only serves as a timeout.</p>
<p>Example:
<img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/preempted.png"></p>
<h3 id="round-robin">Round robin</h3>
<p>Use <code>Scheduler::setSchedulingPolicy(SchPolicyRoundRobin)</code>. </p>
<p>This algorithm is usually sufficient for many usages, it's a pretty average algorithm in many criteria. </p>
<p>The next task to execute is the next one of the previously executed task.</p>
<p>This algorithm has the feature to allocate a CPU time slot proportional to the priority of the selected task:</p>
<ul>
<li>30ms for task with a low priority</li>
<li>60ms for task with a normal priority</li>
<li>90ms for task with a high priority</li>
</ul>
<p>In this way, a high priority task has more time to complete its work. Furthermore, all tasks are sure to be served, there is 
no starvation.</p>
<p>Example step by step:
<img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/roundrobin.png"></p>
<h3 id="random-priority">Random priority</h3>
<p>Use <code>Scheduler::setSchedulingPolicy(SchPolicyRandomPriority)</code>. </p>
<p>This algorithm is moderately complex. It chooses a priority at random with probability proportional to the priority. </p>
<p>In the present case we have:</p>
<ul>
<li>PrHigh: 50% chance of being chosen</li>
<li>PrNormal 33% chance of being chosen</li>
<li>PrLow 17% chance of being chosen</li>
</ul>
<p>The algorithm selects the first task corresponding to the chosen priority. 
Then, the task is moved in tail of the queue to prevent it from being selected again in the future (for this given priority).</p>
<p>This algorithm avoids starvation by serving all tasks. The CPU time slot allocated for the selected task 
is constant but shorter than for the preempted algorithm (80ms).</p>
<p>Example step by step:
<img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/randompriority.png"></p>
<h3 id="intelligent">Intelligent</h3>
<p>Use <code>Scheduler::setSchedulingPolicy(SchPolicyIntelligent)</code>. </p>
<p>This algorithm is a little bit complex. </p>
<p>The chosen task depends on several criteria. A score will be assigned for each task.
The task with the highest score will be selected as the next task to resume. The score is calculated by adding:</p>
<ul>
<li>The priority of the task (PrLow: 10 pts, PrNormal: 20 pts, PrHigh: 30 pts)</li>
<li>The waiting time since its last execution: (milliseconds / 100) pts</li>
<li>Messages waiting in the mailbox: 20 pts</li>
</ul>
<p>All tasks are sure to be served, that avoids starvation. </p>
<p>When a higher priority task than current one is added in the ready 
queue (i.e alive tasks, state StQueuing), a context switching is 
performed.</p>
<p>The response time of the tasks that have been waiting the longest time is reduced.</p>
<p>The CPU time slot allocated for the task is equal to the highest score multiplied by 4.</p>
<h2 id="comparison-of-the-differents-algorithms">Comparison of the differents algorithms</h2>
<table class="table table-striped table-hover">
<thead>
<tr>
<th>Algorithm</th>
<th>Return speed</th>
<th>Starvation-free</th>
<th>Predictable</th>
<th>Responsiveness of high priority tasks</th>
<th>Compatible with a hard real time context</th>
<th>Responsiveness of tasks woken up</th>
<th>CPU task time slot</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cooperative</td>
<td>High</td>
<td>Dependent on user</td>
<td>Yes</td>
<td>Dependent on user</td>
<td>Yes</td>
<td>Immediate*</td>
<td>Dependent on user</td>
</tr>
<tr>
<td>Preemptive</td>
<td>High</td>
<td>No</td>
<td>Yes</td>
<td>High</td>
<td>Yes</td>
<td>Depends**</td>
<td>Constant and long</td>
</tr>
<tr>
<td>Round Robin</td>
<td>High</td>
<td>Yes</td>
<td>Yes</td>
<td>Low</td>
<td>No</td>
<td>Low</td>
<td>Depending on priority</td>
</tr>
<tr>
<td>Random priority</td>
<td>Medium</td>
<td>Yes</td>
<td>No</td>
<td>Average</td>
<td>No</td>
<td>Average</td>
<td>Constant</td>
</tr>
<tr>
<td>Intelligent</td>
<td>Low</td>
<td>Yes</td>
<td>Hardly</td>
<td>High</td>
<td>No</td>
<td>High</td>
<td>Variable</td>
</tr>
</tbody>
</table>
<p>* By using the Arduino <code>delay()</code> function. Otherwise, by using <code>Task::sleep()</code>, the kernel yields the current task to another and you have to check yourself when resume the sleeping task.</p>
<p>** If the woken up task has the highest priority among the other tasks, the response time is immediate, 
otherwise the task will never be executed as long as it can not have the highest priority among the other tasks.</p>
<h2 id="interruptions-management">Interruptions management</h2>
<blockquote>
<p>warning This section is for informed users.
In this tutorial, you have seen in the examples <code>OS48_ATOMIC_BLOCK</code>. 
By using it, you inform the compiler to forbid all interruptions in the section between braces. 
A lot of kernel functions need to be atomic by using internally <code>OS48_ATOMIC_BLOCK</code>. Actually the kernel provides 3 sorts of non-interruption in <em>Herlpers.h</em>:</p>
</blockquote>
<ul>
<li><code>OS48_ATOMIC_BLOCK</code> is the most safe ones because all interrupts are disabled and nothing can disturb your code section between braces.</li>
<li><code>OS48_NO_KT_BLOCK</code> which means <em>block of no kernel clock ticks</em> allows your code section to be interrupted by some external interrupts but not by the kernel interrupt.</li>
<li><code>OS48_NO_CS_BLOCK</code> which means <em>block of no context switches</em>
 allows your code section to be interrupted by any interrupts but forbid
 the kernel to yield the task to another between braces. In other words,
 no context switch occurs but some checks (such as wake up sleeping 
tasks, detect stack overflows) are done by the kernel.</li>
</ul>
<blockquote>
<p>Interrupts that have not been able to execute in an atomic block will be executed just after.</p>
</blockquote>
<!-- -->

<blockquote>
<p>The kernel tick disables all interrupts by default. Redefining  <code>OS48_KERNEL_SAFETY_BLOCK</code> has no effect because it works only in kernel functions and not in the kernel tick interrupt.
Allow interrupts inside the kernel tick can have some bad impacts and cause inconsistencies. 
If you really know what you to want and what you do some extra functions are provided
to enable interrupts, as soon as possible,  just after saving the context of the task (only 5 microseconds for UNO and MEGA).
These functions are <code>setKernelTickEnterFnc(void_fnc_t);</code> and <code>setKernelTickExitFnc(void_fnc_t fnc);</code>. You can enable interrupts inside 
and, if you want, forbid the context switch by calling <code>os48_disable_context_switch()</code>. Don't forget to re-enable the context switch after.</p>
</blockquote>
<h2 id="concurrency">Concurrency</h2>
<p>One of most important aspects with multi-tasking programs is the synchronization.
This library provides some synchronization controls.</p>
<p>All synchronization objects in this library have two ways to release waiting tasks. By default the behaviour is FIFO. 
That means that the first waiting task is released first.</p>
<p>But in the constructor of theses classes, you can specify <code>SyncRMHighestPriority</code>.
Example: <code>Sync sync(SyncRMHighestPriority)</code>. <code>SyncRMHighestPriority</code> is the behaviour 
for releasing high priority tasks first. The waiting tasks having the same priority are released as the FIFO behaviour.</p>
<h3 id="events">Events</h3>
<p>The most basic control is the event. An event allows you to stop the execution of some tasks at a specific point
of your program and release one or all the stopped tasks later. This mechanism is useful to warn tasks when
data are available for example. </p>
<p>The class representing this mechanism is <code>Sync</code>.</p>
<p>In comparison, an event can be compared to an exam room . 
The candidates enter the room and wait (<code>Sync::wait()</code>). 
At the time expected, the candidates in the room begin to work  (<code>Sync::releaseAll()</code>). 
Those who arrive late are waiting for the next session (<code>Sync::wait()</code> function called after <code>Sync::releaseAll()</code>). 
The time is the trigger event.</p>
<pre><code class="hljs ocaml">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

<span class="hljs-type">Scheduler</span>* scheduler = <span class="hljs-type">Scheduler</span>::get<span class="hljs-literal">()</span>; 
<span class="hljs-type">Task</span>* task1 = <span class="hljs-type">NULL</span>; 
<span class="hljs-type">Task</span>* task2 = <span class="hljs-type">NULL</span>;
<span class="hljs-type">Task</span>* task3 = <span class="hljs-type">NULL</span>;

void setup<span class="hljs-literal">()</span> {
  <span class="hljs-type">Serial</span>.<span class="hljs-keyword">begin</span>(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func1, <span class="hljs-number">60</span>);
  task2 = scheduler-&gt;createTask(&amp;func2, <span class="hljs-number">60</span>);
  task3 = scheduler-&gt;createTask(&amp;func3, <span class="hljs-number">60</span>);

  scheduler-&gt;start<span class="hljs-literal">()</span>;
}

<span class="hljs-type">Sync</span> sync;
const <span class="hljs-built_in">char</span>* hexData = <span class="hljs-string">"A223E4AB594C"</span>;

void func1<span class="hljs-literal">()</span>
{ 
  task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">3000</span>);
  sync.releaseOne<span class="hljs-literal">()</span>;
  task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">2000</span>);
  sync.releaseOne<span class="hljs-literal">()</span>;
}

void func2<span class="hljs-literal">()</span>
{
  task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">1000</span>);     
  sync.wait<span class="hljs-literal">()</span>;
  <span class="hljs-type">OS48_NO_CS_BLOCK</span>
  {    
    <span class="hljs-type">Serial</span>.print(<span class="hljs-string">"Task2 can now process data: "</span>);
    <span class="hljs-type">Serial</span>.println(hexData);
  }
}

void func3<span class="hljs-literal">()</span>
{
  task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">2000</span>); 
  sync.wait<span class="hljs-literal">()</span>;
  <span class="hljs-type">OS48_NO_CS_BLOCK</span>
  {    
    <span class="hljs-type">Serial</span>.print(<span class="hljs-string">"Task3 can now process data: "</span>);
    <span class="hljs-type">Serial</span>.println(hexData);
  }
}

void loop<span class="hljs-literal">()</span> {} 
</code></pre>

<blockquote>
<p>warning Pay attention to the order of operations! If you call one of 
the release methods in a task and if there is no task pending in the 
waiting queue, the next task calling <code>Sync::wait()</code> will wait.</p>
</blockquote>
<h3 id="barriers">Barriers</h3>
<p>The class representing this mechanism is <code>Barrier</code>.</p>
<p>A task calling the wait method (<code>Barrier::wait()</code>) will wait until the number of pending tasks does not reach the threshold set initially. 
Once reached the threshold, all pending tasks will be released. 
The following calls to the wait method will be ignored and immediately released.</p>
<p>A barrier is like a dining table. Those already sitted wait. 
When all family members sat (the threshold), they can start eating.</p>
<pre><code class="hljs gradle">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

Scheduler* scheduler = Scheduler::get(); 
<span class="hljs-keyword">Task</span>* task1 = <span class="hljs-keyword">NULL</span>; 
<span class="hljs-keyword">Task</span>* task2 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task3 = <span class="hljs-keyword">NULL</span>;

<span class="hljs-keyword">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func1, <span class="hljs-number">60</span>);
  task2 = scheduler-&gt;createTask(&amp;func2, <span class="hljs-number">60</span>);
  task3 = scheduler-&gt;createTask(&amp;func3, <span class="hljs-number">60</span>);

  scheduler-&gt;start();
}

Barrier barrier(<span class="hljs-number">2</span>); <span class="hljs-comment">//threshold = 2 tasks</span>

<span class="hljs-keyword">void</span> func1()
{ 
  <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//simulate a process</span>
  barrier.wait();
  OS48_ATOMIC_BLOCK
  {    
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Task1 released"</span>);
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Checkpoint reached"</span>);
  }
}

<span class="hljs-keyword">void</span> func2()
{
  <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">1500</span>); <span class="hljs-comment">//simulate a process</span>
  barrier.wait();
  OS48_NO_CS_BLOCK
  {    
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Task2 released"</span>);
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Checkpoint reached"</span>);
  }
}

<span class="hljs-keyword">void</span> func3()
{
  <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">5000</span>); <span class="hljs-comment">//simulate a process</span>
  barrier.wait();
  OS48_ATOMIC_BLOCK
  {    
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Task 3 did not have to wait."</span>);
  }
}

<span class="hljs-keyword">void</span> loop() {}
</code></pre>

<h3 id="semaphores">Semaphores</h3>
<p>The class representing this mechanism is <code>Semaphore</code>.</p>
<p>A semaphore is a synchronization mechanism that controls access by multiple task to a common resource.</p>
<p>When you create a semaphore, you have to specify the maximum of tasks that can acquire it.
When the maximum calls of <code>Semaphore::acquire()</code> is reached, the following tasks will wait a call to
<code>Semaphore::release()</code>.</p>
<p>An elevator can be a representation of the usage of a semaphore. A 
maximum number of persons is allowed. 
When a person leaves the elevator, another person who is waiting can 
enter. According to the established rule, the person who can enter is :</p>
<ul>
<li>The person who waited the longest (FIFO)</li>
<li>A disabled person (high priority tasks, ordered by waiting time).</li>
</ul>
<blockquote>
<p>Any tasks can release a semaphore, not necessarily the task which has acquired the semaphore.</p>
</blockquote>
<!-- -->

<blockquote>
<p>You can create a binary semaphore by allowing one task at a time.</p>
</blockquote>
<pre><code class="hljs gradle">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

Scheduler* scheduler = Scheduler::get();
<span class="hljs-keyword">Task</span>* task1 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task2 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task3 = <span class="hljs-keyword">NULL</span>;

<span class="hljs-keyword">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">60</span>);
  task2 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">60</span>);
  task3 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">60</span>);

  scheduler-&gt;start();
}

Semaphore sem(<span class="hljs-number">2</span>);

<span class="hljs-keyword">void</span> func()
{
  <span class="hljs-keyword">for</span> (;;)
  {    
    OS48_NO_CS_BLOCK
    {
      sem.acquire();
      Serial.<span class="hljs-keyword">print</span> (<span class="hljs-string">"In "</span>);
      Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getId());      
    }

    <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">1000</span>);


    OS48_NO_CS_BLOCK
    {    
      sem.release();
      Serial.<span class="hljs-keyword">print</span> (<span class="hljs-string">"Out "</span>);
      Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getId());

      scheduler-&gt;yield(); <span class="hljs-comment">//recommended to not loop too fast in order that others tasks can acquire the semaphore</span>
    }
  }
}

<span class="hljs-keyword">void</span> loop() {}
</code></pre>

<blockquote>
<p>warning That's optionnal, but you shouldn't omit <code>scheduler-&gt;yield();</code>
 in some cases. In this example the task 
reloops immediately and tries to acquire again the semaphore. Without 
the yield function, some tasks risk to never acquire the semaphore in 
time.</p>
</blockquote>
<h3 id="mutexes">Mutexes</h3>
<p>The class representing this mechanism is <code>Mutex</code>.</p>
<p>A mutex is a high level synchronization mechanism. 
While a binary semaphore may be used as a mutex, a mutex is a more specific use-case, which allows extra guarantees:</p>
<ul>
<li>Mutexes have a concept of an owner. Only the task that locked the mutex can unlock it.</li>
<li>Mutexes provide priority inversion safety. To avoid deadlocks, it 
promote the priority of the owner whenever a higher-priority task starts
 waiting on the mutex.</li>
<li>Mutexes also provide deletion safety, when the owner has been aborted or deleted, the mutext is reset to avoid deadlocks.</li>
</ul>
<p>A mutex is like a checkout of a supermarket. Only one person can pass at a time. Only this person can release the checkout.</p>
<p>Priority inversion safety example:</p>
<pre><code class="hljs gradle">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

Scheduler* scheduler = Scheduler::get();
<span class="hljs-keyword">Task</span>* task1 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task2 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task3 = <span class="hljs-keyword">NULL</span>;

<span class="hljs-keyword">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">60</span>, PrLow);
  task2 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">60</span>);
  task3 = scheduler-&gt;createTask(&amp;funcHPrior, <span class="hljs-number">60</span>);

  scheduler-&gt;setSchedulingPolicy(SchPolicyPreemptive);
  scheduler-&gt;start();
}

Mutex mutex;
Semaphore sem;

<span class="hljs-keyword">void</span> func()
{
  <span class="hljs-comment">//exceptionally, choose the task 1 to ensure the lowest priority task is the first to execute the next code</span>

  <span class="hljs-comment">//let this task sleep in order to let the scheduler choose the task 1 </span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">task</span>()-&gt;getId() == <span class="hljs-number">2</span>)
    <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">200</span>); 

  <span class="hljs-keyword">for</span> (;;)
  {
    OS48_NO_CS_BLOCK
    {
      mutex.lock();
      <span class="hljs-comment">//sem.acquire();</span>

      Serial.<span class="hljs-keyword">print</span> (<span class="hljs-string">"In "</span>);
      Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getId());
    }

    <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">2000</span>);

    OS48_NO_CS_BLOCK
    {
      Serial.<span class="hljs-keyword">print</span> (<span class="hljs-string">"Out "</span>);
      Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getId());

      mutex.unlock();
      <span class="hljs-comment">//sem.release();   </span>
    }
  }
}

<span class="hljs-keyword">void</span> funcHPrior()
{
  <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">200</span>); <span class="hljs-comment">//let this task sleep in order to let the scheduler choose the task 1 </span>

  <span class="hljs-keyword">for</span> (;;)
  {
    OS48_NO_CS_BLOCK
    {
      Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"HP"</span>);
    }

    uint32_t m = millis();
    <span class="hljs-keyword">while</span> (millis() - m &lt; <span class="hljs-number">1000</span>) {} <span class="hljs-comment">//busy wait</span>
  }
}

<span class="hljs-keyword">void</span> loop() {}
</code></pre>

<p>The above example illustrates how works the priority inversion 
safety. When the task 2 tries to acquire the lock on the mutex, the task
 1
which has a lower priority gets the same priority than the task 2. In 
this way, the scheduler can't
always choose the task 3 (because task 2 is waiting and task 1 won't be 
able to be chosen by keeping its original
priority). If you uncomment the lines corresponding to the semaphore and
 if you comment the lines corresponding to the mutex
(in order to enable the semaphore instead of the mutex), you will notice
 that the task 3 will be always chosen and the task 2 can no longer 
acquire the semaphore.</p>
<p>Reentrance example:</p>
<pre><code class="hljs livescript"><span class="hljs-comment">#include &lt;os48.h&gt;</span>

using namespace os48;

Scheduler* scheduler = <span class="hljs-attribute">Scheduler</span>::get();
Task* task1 = NULL;
Task* task2 = NULL;

<span class="hljs-literal">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">100</span>);
  task2 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">100</span>);

  scheduler-&gt;start();
}

Mutex mutex;

<span class="hljs-literal">void</span> func()
{
  reentrantFunction(<span class="hljs-number">10</span>);
}

<span class="hljs-literal">void</span> reentrantFunction(uint8_t counter)
{
  OS48_NO_CS_BLOCK
  {
    mutex.lock();

    Serial.<span class="hljs-built_in">print</span> (<span class="hljs-string">"In "</span>);
    Serial.println<span class="hljs-function"><span class="hljs-params">(task()-&gt;getId())</span>;
    <span class="hljs-title">Serial</span>.<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"Counter in : "</span>)</span>;
    <span class="hljs-title">Serial</span>.<span class="hljs-title">println</span><span class="hljs-params">(counter)</span>;
  }

  <span class="hljs-title">task</span><span class="hljs-params">()</span>-&gt;</span>sleep(<span class="hljs-number">300</span>);

  <span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>)
    reentrantFunction(counter - <span class="hljs-number">1</span>);

  task<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>sleep(<span class="hljs-number">300</span>);

  OS48_NO_CS_BLOCK
  {
    mutex.unlock();

    Serial.<span class="hljs-built_in">print</span> (<span class="hljs-string">"Out "</span>);
    Serial.println<span class="hljs-function"><span class="hljs-params">(task()-&gt;getId())</span>;
    <span class="hljs-title">Serial</span>.<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"Counter out : "</span>)</span>;
    <span class="hljs-title">Serial</span>.<span class="hljs-title">println</span><span class="hljs-params">(counter)</span>;
  }
}

<span class="hljs-title">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> {}
</span></code></pre>

<p>Deletion safety: </p>
<pre><code class="hljs ocaml">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

<span class="hljs-type">Scheduler</span>* scheduler = <span class="hljs-type">Scheduler</span>::get<span class="hljs-literal">()</span>;
<span class="hljs-type">Task</span>* task1 = <span class="hljs-type">NULL</span>;
<span class="hljs-type">Task</span>* task2 = <span class="hljs-type">NULL</span>;
<span class="hljs-type">Task</span>* task3 = <span class="hljs-type">NULL</span>;

void setup<span class="hljs-literal">()</span> {
  <span class="hljs-type">Serial</span>.<span class="hljs-keyword">begin</span>(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">100</span>);
  task2 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">100</span>, <span class="hljs-type">PrHigh</span>);
  task3 = scheduler-&gt;createTask(&amp;funcDelete, <span class="hljs-number">100</span>);

  scheduler-&gt;start<span class="hljs-literal">()</span>;
}

<span class="hljs-type">Mutex</span> mutex;

void func<span class="hljs-literal">()</span>
{
  <span class="hljs-type">OS48_NO_CS_BLOCK</span>
  {
    mutex.lock<span class="hljs-literal">()</span>;

    <span class="hljs-type">Serial</span>.print (<span class="hljs-string">"In "</span>);
    <span class="hljs-type">Serial</span>.println(task<span class="hljs-literal">()</span>-&gt;getId<span class="hljs-literal">()</span>);
  }

  task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">6000</span>);

  <span class="hljs-type">OS48_NO_CS_BLOCK</span>
  {
    mutex.unlock<span class="hljs-literal">()</span>;

    <span class="hljs-type">Serial</span>.print (<span class="hljs-string">"Out "</span>);
    <span class="hljs-type">Serial</span>.println(task<span class="hljs-literal">()</span>-&gt;getId<span class="hljs-literal">()</span>);
  }
}

void funcDelete<span class="hljs-literal">()</span>
{
  task<span class="hljs-literal">()</span>-&gt;sleep(<span class="hljs-number">4000</span>);

  <span class="hljs-type">OS48_NO_CS_BLOCK</span>
  {
    <span class="hljs-type">Serial</span>.println(<span class="hljs-string">"task2 deleted"</span>);
    scheduler-&gt;deleteTask(task2);
  }
}

void loop<span class="hljs-literal">()</span> {}
</code></pre>

<h3 id="monitors">Monitors</h3>
<p>A monitor is a synchronization construct that allows threads to have 
both mutual exclusion and the ability to wait (block) for a certain 
condition to become true.
Monitors also have a mechanism for signalling other threads that their 
condition has been met. 
A monitor consists of a mutex object and condition variables. In this 
library condition variables consists of a Sync object and a condition.</p>
<p>The library provides helpers to build a monitor in file @em Monitor_helpers.h.
Example: </p>
<pre><code class="hljs gradle">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;

using namespace os48;

Scheduler* scheduler = Scheduler::get();
<span class="hljs-keyword">Task</span>* task1 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task2 = <span class="hljs-keyword">NULL</span>;
<span class="hljs-keyword">Task</span>* task3 = <span class="hljs-keyword">NULL</span>;

<span class="hljs-keyword">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">100</span>);
  task2 = scheduler-&gt;createTask(&amp;func, <span class="hljs-number">100</span>, PrHigh);
  task3 = scheduler-&gt;createTask(&amp;funcCondition, <span class="hljs-number">100</span>);

  scheduler-&gt;start();
}

<span class="hljs-keyword">volatile</span> bool condition = <span class="hljs-keyword">false</span>;
Mutex mutex;
Sync sync;

<span class="hljs-keyword">void</span> func()
{
  OS48_NO_CS_BLOCK
  {
    Serial.<span class="hljs-keyword">print</span> (<span class="hljs-string">"In "</span>);
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getId());
  }

  OS48_NO_CS_BLOCK
  {
    Serial.<span class="hljs-keyword">print</span>(<span class="hljs-keyword">task</span>()-&gt;getId());
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">" is waiting until condition is true..."</span>);
  }

  OS48_MONITOR_ENTER(&amp;mutex); <span class="hljs-comment">//acquires the lock</span>
  OS48_MONITOR_WAIT_UNTIL(condition, &amp;mutex, &amp;sync); <span class="hljs-comment">//releases the lock and waits. When task is woken up, re-acquires the lock</span>

  OS48_NO_CS_BLOCK
  {
    Serial.<span class="hljs-keyword">print</span>(<span class="hljs-keyword">task</span>()-&gt;getId());
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">" does  something..."</span>);
  }

  <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">2000</span>);

  OS48_MONITOR_EXIT(&amp;mutex); <span class="hljs-comment">//releases the lock</span>

  OS48_NO_CS_BLOCK
  {
    Serial.<span class="hljs-keyword">print</span> (<span class="hljs-string">"Out "</span>);
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">task</span>()-&gt;getId());
  }
}

<span class="hljs-keyword">void</span> funcCondition()
{
  <span class="hljs-keyword">task</span>()-&gt;sleep(<span class="hljs-number">4000</span>);

  OS48_NO_CS_BLOCK
  {
    Serial.<span class="hljs-keyword">println</span>(<span class="hljs-string">"task 3 sets condition to true"</span>);
    condition = <span class="hljs-keyword">true</span>;
    sync.releaseAll(); <span class="hljs-comment">//notifies the condition has changed</span>
  }
}

<span class="hljs-keyword">void</span> loop() {}
</code></pre>

<h2 id="messages">Messages</h2>
<p>Tasks can send messages to other tasks. That allows a communication between tasks. 
Each task have a message box (messages are internally stored in a queue) and you can pick up a specific category of message.</p>
<p>A message is composed of a code in order to categorize the message, optionaly a content of any type.</p>
<p>You only need 4 functions: <code>Scheduler::sendMessage()</code>, <code>Task::peekMessage()</code>, <code>Task::getNextMessage()</code> and <code>Task::waitNextMessage()</code>.</p>
<p>The body of a message is of type <em>databag_t</em>. See <em>Helpers.h</em> to see the complete declaration of the type. This is an <em>union</em>
 type, which means that
you can store any type of 32bits length or less (pointer + size of data,
 string, intergers, float, ...). The message class has some constructor 
helpers
in order to hide the usage of <em>databag_t</em> except for decoding the message body at the reception.</p>
<pre><code class="hljs livescript"><span class="hljs-comment">#include &lt;os48.h&gt;</span>

using namespace os48;

Scheduler* scheduler = <span class="hljs-attribute">Scheduler</span>::get();

Task* task1 = NULL;
Task* task2 = NULL;
Task* task_print = NULL;
Task* task_print_error = NULL;

<span class="hljs-literal">void</span> setup() {
  Serial.begin(<span class="hljs-number">9600</span>);
  task1 = scheduler-&gt;createTask(&amp;func1, <span class="hljs-number">60</span>);
  task2 = scheduler-&gt;createTask(&amp;func2, <span class="hljs-number">60</span>);
  task_print = scheduler-&gt;createTask(&amp;funcPrint, <span class="hljs-number">60</span>);
  task_print_error = scheduler-&gt;createTask(&amp;funcPrintErrors, <span class="hljs-number">60</span>);

  scheduler-&gt;start();
}

<span class="hljs-keyword">const</span> byte code_print = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> byte code_print_error = <span class="hljs-number">2</span>;

<span class="hljs-literal">void</span> func1()
{
  scheduler-&gt;sendMessage(task_print, <span class="hljs-keyword">new</span> Message(code_print, <span class="hljs-string">"hello world!"</span>)); 

  task<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>sleep(<span class="hljs-number">3000</span>);

  scheduler-&gt;sendMessage(task_print_error, <span class="hljs-keyword">new</span> Message(code_print_error, <span class="hljs-string">"fire in the hole!"</span>));

  task<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>sleep(<span class="hljs-number">3000</span>);

  <span class="hljs-pi">//this message won't be printed because task_print expects only messages with the code: code_print
  //</span><span class="hljs-keyword">and</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> the <span class="hljs-keyword">case</span> here.
  scheduler-&gt;sendMessage(task_print, <span class="hljs-keyword">new</span> Message(code_print_error, <span class="hljs-string">"this message will be ignored"</span>));
}

<span class="hljs-literal">void</span> func2()
{
  scheduler-&gt;sendMessage(task_print_error, <span class="hljs-keyword">new</span> Message(code_print_error, <span class="hljs-string">"this is not an exercice!"</span>));

  task<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>sleep(<span class="hljs-number">2000</span>);

  scheduler-&gt;sendMessage(task_print, <span class="hljs-keyword">new</span> Message(code_print, <span class="hljs-string">"hello world again!"</span>));

  task<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>sleep(<span class="hljs-number">2000</span>);

  <span class="hljs-pi">//this message won't be printed because task_print_error expects only messages with the code: code_print_error
  //</span><span class="hljs-keyword">and</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> the <span class="hljs-keyword">case</span> here.
  scheduler-&gt;sendMessage(task_print_error, <span class="hljs-keyword">new</span> Message(code_print, <span class="hljs-string">"this message will be ignored"</span>)); 
}

<span class="hljs-literal">void</span> funcPrint()
{
  <span class="hljs-keyword">for</span> (;;)
  {
    Message* mess = task<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>waitNextMessage(code_print);
    OS48_NO_CS_BLOCK
    {
      Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">"Message is: "</span>);
      Serial.println(mess-&gt;getBody().bStr);
      <span class="hljs-keyword">delete</span> mess;
    }   
  }
}

<span class="hljs-literal">void</span> funcPrintErrors()
{
  <span class="hljs-keyword">for</span> (;;)
  {
    Message* mess = task<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>waitNextMessage(code_print_error);
    OS48_NO_CS_BLOCK
    {
      Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">"ERROR message is: "</span>);
      Serial.println(mess-&gt;getBody().bStr);
      <span class="hljs-keyword">delete</span> mess;   
    }
  }
}

<span class="hljs-literal">void</span> <span class="hljs-keyword">loop</span>() {}
</code></pre>

<p>The above example shows two senders and two receivers. Their work is to print messages.</p>
<blockquote>
<p>To know if you need to delete the message (if the message has been instancied in the heap memory), 
you can use the <em>Message::setFlags(uint8_t)</em> function. 
This is a free parameter to use. 
For example the first least significant bit can be set to 1 to inform the receiver of the message to delete the message.
In the above example, all messages are created with the <em>new</em> operator, so we don't need flags.</p>
</blockquote>
<p>The message box can store an unlimited messages. You can explicitly limit the emission of messages with a semaphore.
Take a look to this example. A wrapper has been created to send messages.</p>
<pre><code class="hljs cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;os48.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> os48;

Scheduler* scheduler = Scheduler::get();

Task* tProducer1 = NULL;
Task* tProducer2 = NULL;
Task* tConsumer = NULL;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  Serial.begin(<span class="hljs-number">9600</span>);
  tProducer1 = scheduler-&gt;createTask(&amp;producer1, <span class="hljs-number">60</span>);
  tProducer2 = scheduler-&gt;createTask(&amp;producer2, <span class="hljs-number">60</span>);
  tConsumer = scheduler-&gt;createTask(&amp;consumer, <span class="hljs-number">60</span>);

  scheduler-&gt;start();
}

<span class="hljs-keyword">const</span> byte code = <span class="hljs-number">1</span>;
<span class="hljs-function">Semaphore <span class="hljs-title">limiter</span><span class="hljs-params">(3)</span></span>; <span class="hljs-comment">//message box is limited to 3 messages max.</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendAMessageToConsumer</span><span class="hljs-params">(os48::Message* msg)</span>
</span>{
  limiter.acquire();
  scheduler-&gt;sendMessage(tConsumer, msg);    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer1</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">for</span>(;;)
  {
     sendAMessageToConsumer(<span class="hljs-keyword">new</span> Message(code, <span class="hljs-string">"flooding from producer 1!"</span>));
  }  
}


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer2</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">for</span>(;;)
  {
     sendAMessageToConsumer(<span class="hljs-keyword">new</span> Message(code, <span class="hljs-string">"flooding from producer 2!"</span>));   
  }  
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">for</span> (;;)
  {
    Message* mess = task()-&gt;waitNextMessage(code);
    limiter.release();
    OS48_ATOMIC_BLOCK
    {
      Serial.print(<span class="hljs-string">"Message is: "</span>);
      Serial.println(mess-&gt;getBody().bStr);
      <span class="hljs-keyword">delete</span> mess;
    } 
  }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{}
</code></pre>

<p>Limiting the number of messages for a task is a good practice to avoid memory overflows if you plan to send 
frequently messages to a task.</p>
<p><img alt="Screenshot" src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/message_box.png"></p>
<!-- -->

<blockquote>
<p>You can abort <code>Task::waitNextMessage()</code> with 
<code>Task::resume()</code>. The function has also a timeout argument if you don't want to wait indefinitely.</p>
</blockquote>
<!-- -->

<blockquote>
<p>In order to clear all messages of a task, you can call many times the function <code>Task::getNextMessage()</code> with <em>0</em> as message code.
When the function returns <em>NULL</em> the message list is empty.</p>
</blockquote></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/jquery-1.js"></script>
        <script src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/bootstrap-3.js"></script>
        <script src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/highlight.js"></script>
        <script src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/base.js"></script>
        <script src="Advanced%20usage%20-%20OS48%20%28RTOS48%29_fichiers/style.js"></script>
    
</body></html>